<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>牛小聪</title>
  
  
  <link href="https://niuxiaocong.github.io/atom.xml" rel="self"/>
  
  <link href="https://niuxiaocong.github.io/"/>
  <updated>2021-08-24T15:10:33.981Z</updated>
  <id>https://niuxiaocong.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法基础</title>
    <link href="https://niuxiaocong.github.io/2021/08/23/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://niuxiaocong.github.io/2021/08/23/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-23T09:13:20.000Z</published>
    <updated>2021-08-24T15:10:33.981Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>异或操作规律</p><p>性质1</p><p>0^N = N，N^N = 0</p><p>性质2</p><p>异或运算满足交换律和结合律</p><p>a^b = b^a </p><p>a^b^c = a^(b^c)</p><h3 id="题目：在一个数组中，已知只有一个数出现了奇数次，其他的数出现了偶数次，请找出这个出现奇数次的数"><a href="#题目：在一个数组中，已知只有一个数出现了奇数次，其他的数出现了偶数次，请找出这个出现奇数次的数" class="headerlink" title="题目：在一个数组中，已知只有一个数出现了奇数次，其他的数出现了偶数次，请找出这个出现奇数次的数"></a>题目：在一个数组中，已知只有一个数出现了奇数次，其他的数出现了偶数次，请找出这个出现奇数次的数</h3><h3>那么有两种出现了奇数次，剩余的数出现了偶数次，应该怎么找</h3><pre><code class="java">package com.java1;public class QuestOneDemo &#123;        public static void main(String[] args) &#123;        int[] arr = &#123;1,1,2,2,2,2,3,3,3,4&#125;;        //printOddTiemsNumsOne(arr);        printOddTiemsNumsTwo(arr);    &#125;    //第一個問題    public static void printOddTiemsNumsOne(int[] arr) &#123;        int eor = 0;        for(int cur : arr) &#123;            eor ^= cur;        &#125;        System.out.println(eor);    &#125;    // 第二个问题    public static void printOddTiemsNumsTwo(int[] arr) &#123;        int eor = 0;        for(int cur : arr) &#123;            eor ^= cur;        &#125;        //eor = a^b        //eor != 0        //eor 位置上必然有一個是1        int rightOne = eor &amp; (~eor + 1);                int onlyOne = 0; //eor&#39;                for(int cur : arr) &#123;            if((cur &amp; rightOne) == 1) &#123;                onlyOne ^= cur;            &#125;        &#125;        System.out.println(onlyOne + &quot; &quot; + (eor ^ onlyOne));            &#125;&#125;</code></pre><h3 id="题目：二分查找法"><a href="#题目：二分查找法" class="headerlink" title="题目：二分查找法"></a>题目：二分查找法</h3><ul><li>在一个有序的数组中，寻找某个数是否存在</li></ul><p>两种思路递归和非递归</p><h4 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h4><p>代码实现</p><pre><code class="java">    //非递归的方式    public static boolean doubleBranch(int[] arr,int target) &#123;            if(arr == null || arr.length == 0) &#123;            return false;        &#125;        int right = arr.length-1;    //右侧的指针        int left = 0;               //左侧指针        int mid = 0;               //中间指针        boolean isFind = false;        //是否找到target目标元素                while(right&gt;=left) &#123;        //左侧指针如果大于右侧指针则结束循环            mid = (right + left) / 2;    //找到中间元素的坐标            if(arr[mid] == target) &#123;    //找到 将isFind 置为true                isFind = true;                break;            &#125;else if(arr[mid] &gt; target) &#123;    //证明目标元素在左侧                right = mid -1;            &#125;else &#123;                           //证明目标元素在这个数组中间位置的右侧                left = mid + 1;            &#125;        &#125;        return isFind;    &#125;</code></pre><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><p>代码实现</p><pre><code class="java">    //递归方式实现    public static boolean doubleBranchDiGui(int[] arr,int left,int right,int target) &#123;                int L = left;                        int R = right;        int Mid = (R - L)/2 + L;        boolean isFind = false;                        if(arr[Mid] &gt; target) &#123;            return doubleBranchDiGui(arr, L, Mid-1,target);        &#125;else if(arr[Mid] &lt; target) &#123;            return doubleBranchDiGui(arr, Mid+1,R,target);        &#125;else if(arr[Mid] == target)&#123;            return true;        &#125;        return false;    &#125;</code></pre><ul><li>在一个有序的数组中，找&gt;=某个数最左侧的位置</li></ul><ul><li>局部最小值问题</li></ul><p>master公式</p><p>T(N) = a*T(N/b) + O(n^d)</p><p>​    T(N)：总问题的数据规模</p><p>​    a：调用次数</p><p>​    T(N/b)：子问题的规模</p><p>log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a))</p><p>log(b,a) = d -&gt; 复杂度为O(N^d * logN)</p><p>log(b,a) &lt; d -&gt; 复杂度为O(N^d)</p><h3 id="题目：小和问题"><a href="#题目：小和问题" class="headerlink" title="题目：小和问题"></a>题目：小和问题</h3><p>在一个数组中，每一个数左边比当前数小的累加起来来，叫做这个数组的小和，求一个数组的小和。</p><p>例如：[1，3，4，2，5] 1左边比1小的数，没有、3左边比3小的数 1、4左边比4小的数1，3、2左边比2小的数1、5左边比5小的数1，2，4，2 。所以小和累加为1+1+3+1+1+3+4+2 = 16</p><h3 id="题目：荷兰国旗问题"><a href="#题目：荷兰国旗问题" class="headerlink" title="题目：荷兰国旗问题"></a>题目：荷兰国旗问题</h3><p>代码实现</p><pre><code class="java">package com.quick;import java.util.Arrays;public class PartitionDemo &#123;        public static void main(String[] args) &#123;        int[] arr = &#123;3,5,6,7,4,3,5,8&#125;;        //partition1(arr,5);        partition2(arr, 5);        System.out.println(Arrays.toString(arr));    &#125;        //partition 过程    /**     * 将一组数分成两个部分，小于指定数的放在一侧     *     情况1、 i位置的数小于等于目标数据，i位置和小于等于的下一个数交换，小于等于区域的向右阔 i++     *  情况2、如果i位置上的索引大于target、目标数据 直接 i++     */    public static void partition1(int[] arr,int target) &#123;        if(arr == null || arr.length&lt;2) &#123;            return ;        &#125;                int left = -1;   //小于等于的区域                for(int i=0;i&lt;arr.length;i++) &#123;            if(arr[i]&lt;=target) &#123;                left++;                swap(arr, i,left);             &#125;        &#125;    &#125;        //partition 过程    /**     *情况1：如果 i 位置上的数小于目标数据target 让i位置上的数和小于区域的下一个数做交换，小于区域向右边阔，i跳下一个     *情况2：如果 i 位置上的数等于目标数据target i跳下一个     *情况3：如果 i 位置上的数大于目标数据target 让i和 大于区域前一个做交换，大于区域位置想做阔，i原地不动     */    public static void partition2(int[] arr,int target) &#123;        int len = arr.length-1;  //数组的长度        int index = 0;            //数组的下标        int left = -1;            //小于区域的数据        int right = arr.length; //大于区域的数据        while(right!=index) &#123;                    if(arr[index]&lt;target) &#123;                    left++;                swap(arr, index, left);                index++;            &#125;else if(arr[index]&gt;target) &#123;                right--;                swap(arr, index, right);            &#125;else &#123;                            index++;            &#125;        &#125;    &#125;        //交换函数    public static void swap(int[] arr , int i , int j) &#123;        int temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://niuxiaocong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://niuxiaocong.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://niuxiaocong.github.io/2021/08/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://niuxiaocong.github.io/2021/08/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-23T03:00:20.000Z</published>
    <updated>2021-08-24T15:22:07.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常用的排序算法"><a href="#常用的排序算法" class="headerlink" title="常用的排序算法"></a>常用的排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="/2021/08/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210823115539098.png" alt="image-20210823115539098"></p><p>代码实现</p><pre><code class="java">package sort;import java.util.Arrays;public class BubbleSort &#123;    public static void main(String[] args) &#123;        int[] arr= &#123;101,34,119,1&#125;;                int temp = 0;                for(int i=0;i&lt;arr.length-1;i++) &#123;            for(int j=0;j&lt;arr.length-1-i;j++) &#123;                if(arr[j]&gt;arr[j+1]) &#123;                    temp = arr[j];                    arr[j] = arr[j+1];                    arr[j+1] = temp;                &#125;            &#125;        &#125;        System.out.println(Arrays.toString(arr));    &#125;&#125;</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><img src="/2021/08/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210823115556329.png" alt="image-20210823115556329"></p><p>代码实现</p><pre><code class="java">package sort;import java.util.Arrays;public class SelectSort &#123;    public static void main(String[] args) &#123;        int[] arr= &#123;101,34,119,1&#125;;                for(int i=0;i&lt;arr.length-1;i++) &#123;                        int minIndex = i;            int minSum=arr[i];                        for(int j=1+1;j&lt;arr.length;j++) &#123;                if(minSum&gt;arr[j]) &#123;                    minSum = arr[j];                    minIndex = j;                &#125;            &#125;                    if(minIndex!=i) &#123;                arr[minIndex] = arr[i];                arr[i] = minSum;                            &#125;        &#125;            System.out.println(Arrays.toString(arr));    &#125;&#125;</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="/2021/08/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210823184037483.png" alt="image-20210823184037483"></p><p>代码实现</p><pre><code class="java">package sort3;import java.util.Arrays;public class InsertSortDemo &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;9,2,3,8&#125;;        insertSort(arr);        System.out.println(Arrays.toString(arr));    &#125;    //插入方法    public static void insertSort(int[] arr) &#123;        if(arr == null || arr.length&lt;2) &#123;            return ;        &#125;            for(int i=1;i&lt;arr.length;i++) &#123;            for(int j = i-1;j&gt;=0 &amp;&amp; arr[j]&gt;arr[j+1];j--) &#123;                swap(arr, i, j);            &#125;        &#125;    &#125;    //交换方法    public static void swap(int[] arr,int i,int j) &#123;        int temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    &#125;&#125;</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="/2021/08/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210823115608580.png" alt="image-20210823115608580"></p><pre><code class="java">package sort;import java.util.Arrays;public class MergeSortDemo &#123;    //主方法    public static void main(String[] args) &#123;        //int[] arr = &#123;1,3,5,2,4,6&#125;;        int[] arr = &#123;5,4,7,8,2,3&#125;;        process(arr,0,arr.length-1);        //process(arr, 0, arr.length-1);        //merger(arr,0,(arr.length-1)/2,arr.length-1);    &#125;            //递归方法    public static void process(int[] arr,int L,int R) &#123;        if(L == R) &#123;            return ;        &#125;        int mid = L+((R-L)/2);        //int mid = (L+R)/2;        process(arr,L,mid);        process(arr,mid+1,R);        merge(arr,L,mid,R);            &#125;        //合并方法    public static void merge(int arr[],int L,int M,int R) &#123;                int[] help = new int[R-L+1];                int p1 = L;        int p2 = M+1;        int i=0;                while(p1&lt;=M&amp;&amp;p2&lt;=R) &#123;            if(arr[p1]&lt;arr[p2]) &#123;                help[i] = arr[p1];                i++;                p1++;            &#125;else &#123;                help[i] = arr[p2];                i++;                p2++;            &#125;        &#125;                while(p1&lt;=M) &#123;            help[i++] = arr[p1++];        &#125;                        while(p2&lt;=R) &#123;            help[i++] = arr[p2++];        &#125;                        for (i = 0; i &lt; help.length; i++) &#123;            arr[L+i] = help[i];        &#125;                System.out.println(&quot;归并：&quot;+Arrays.toString(help));        &#125;&#125;</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>排序算法中时间复杂度和空间复杂度的对比</p><p><img src="/2021/08/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210823171038054.png" alt="image-20210823171038054"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://niuxiaocong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://niuxiaocong.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="排序算法" scheme="https://niuxiaocong.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="https://niuxiaocong.github.io/2021/08/23/%E6%A0%88/"/>
    <id>https://niuxiaocong.github.io/2021/08/23/%E6%A0%88/</id>
    <published>2021-08-23T02:34:59.000Z</published>
    <updated>2021-08-24T15:10:23.408Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h1><p><img src="/2021/08/23/%E6%A0%88/image-20210823105728346.png" alt="image-20210823105728346"></p><h2 id="使用数组模拟栈结构代码实现"><a href="#使用数组模拟栈结构代码实现" class="headerlink" title="使用数组模拟栈结构代码实现"></a>使用数组模拟栈结构代码实现</h2><pre><code class="java">package com.java.stack;import java.util.Scanner;/** * 使用数组来模拟栈结构 */public class ArrayStackDemo &#123;    public static void main(String[] args) &#123;        StackArr stack = new StackArr(4);        boolean loop = true;        Scanner scan = new Scanner(System.in);        char key = &#39; &#39;;            while(loop) &#123;            System.out.println(&quot;e(exit) 退出&quot;);            System.out.println(&quot;a(add) 入栈操作&quot;);            System.out.println(&quot;r(remove) 出栈操作&quot;);            System.out.println(&quot;t(top) 查看当前栈顶的元素&quot;);            key = scan.next().charAt(0);                        switch(key) &#123;            case &#39;e&#39;:                System.out.println(&quot;**********退出程序**********&quot;);                loop = false;                break;            case &#39;a&#39;:                System.out.println(&quot;**********请输入要入栈的数据**********&quot;);                int val = scan.nextInt();                stack.push(val);                break;            case &#39;r&#39;:                System.out.println(&quot;**********出栈一个数据**********&quot;);                int pop = stack.pop();                System.out.println(&quot;出栈的元素是：&quot;+pop);                break;            case &#39;t&#39;:                System.out.println(&quot;**********查看当前的栈顶元素**********&quot;);                int top = stack.top();                System.out.println(&quot;当前栈顶的元素是：&quot;+top);                break;            default:                System.out.println(&quot;没有这条指令，重新输入&quot;);                break;                    &#125;        &#125;    &#125;&#125;//栈的一个结构class StackArr&#123;        int[] arr = null;   //使用数组模拟栈结构    int maxSize;        //栈的最大容量    int top;            //栈顶指针        public StackArr(int maxSize) &#123;        this.maxSize = maxSize;        arr = new int[maxSize];        top = -1;    &#125;    //空栈    public boolean isEmpty() &#123;        return top==-1?true:false;    &#125;    //满栈    public boolean isFull() &#123;        return top==maxSize-1?true:false;    &#125;    //入栈操作    public void push(int n) &#123;        if(isFull()) &#123;            System.out.println(&quot;满栈，无法加入~~&quot;);            return;        &#125;        arr[++top] = n;     &#125;    //出栈操作    public int pop() &#123;            if(isEmpty()) &#123;            throw new RuntimeException(&quot;空栈，无法进行pop操作&quot;);        &#125;        int value = arr[top--];        return value;    &#125;    //查看栈顶元素    public int top() &#123;        if(isEmpty()) &#123;            throw new RuntimeException(&quot;空栈，栈顶为空&quot;);        &#125;        return arr[top];    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://niuxiaocong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://niuxiaocong.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hexo部署到Github</title>
    <link href="https://niuxiaocong.github.io/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/"/>
    <id>https://niuxiaocong.github.io/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/</id>
    <published>2021-08-23T00:46:53.000Z</published>
    <updated>2021-08-24T15:09:17.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用Hexo搭建一个网站"><a href="#使用Hexo搭建一个网站" class="headerlink" title="使用Hexo搭建一个网站"></a>使用Hexo搭建一个网站</h1><pre><code>需要环境Node.js  14.17.5 (建议在12版本以上都可以)</code></pre><p>Node.js 安装略</p><p>Git 安装略</p><h2 id="安装Hexo的脚手架"><a href="#安装Hexo的脚手架" class="headerlink" title="安装Hexo的脚手架"></a>安装Hexo的脚手架</h2><pre><code>npm install -g hexo-cli</code></pre><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210823090843614.png" alt="image-20210823090843614"></p><h2 id="执行初始化命令"><a href="#执行初始化命令" class="headerlink" title="执行初始化命令"></a>执行初始化命令</h2><pre><code>hexo init他会从github上下载模板，速度会有点慢，也可能会下载失败，多下载几次既可以了</code></pre><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210822181109062.png" alt="image-20210822181109062"></p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><pre><code>hexo g 或者hexo generate</code></pre><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210822181408143.png" alt="image-20210822181408143"></p><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre><code>hexo s</code></pre><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210822181445442.png" alt="image-20210822181445442"></p><p>默认的端口是4000</p><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210822181538026.png" alt="image-20210822181538026"></p><p>一个简单的网站就搭建完毕了。接下来是发布到GitHub上</p><h1 id="发布到GitHub"><a href="#发布到GitHub" class="headerlink" title="发布到GitHub"></a>发布到GitHub</h1><p>创建gitHub账户略</p><h2 id="创建GitHub仓库"><a href="#创建GitHub仓库" class="headerlink" title="创建GitHub仓库"></a>创建GitHub仓库</h2><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210822182336588.png" alt="image-20210822182336588"></p><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210822182513150.png" alt="image-20210822182513150"></p><h2 id="配置-config-yml中有关deploy的部分"><a href="#配置-config-yml中有关deploy的部分" class="headerlink" title="配置_config.yml中有关deploy的部分"></a>配置<code>_config.yml</code>中有关deploy的部分</h2><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210822182905468.png" alt="image-20210822182905468"></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在部署的时候一定要用git bash，会省去很多不必要的麻烦</p><pre><code>hexo d</code></pre><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210822183235152.png" alt="image-20210822183235152"></p><p>出现这个不要慌，因为后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行<code>hexo d</code>的话一般会报上面的这个错误。</p><p>安装一个插件即可</p><pre><code>npm install hexo-deployer-git</code></pre><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210822183444479.png" alt="image-20210822183444479"></p><p>提交到GitHub仓库</p><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210822183850300.png" alt="image-20210822183850300"></p><p>部署命令</p><pre><code>hexo d或者hexo deploy</code></pre><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210822213357819.png" alt="image-20210822213357819"></p><p>总结：部署的步骤</p><p>hexo clean  清空一下生成的html</p><p>hexo generate 重新生成html</p><p>hexo deploy 部署</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><pre><code>hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help  # 查看帮助hexo version  #查看Hexo的版本简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy</code></pre><h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><h2 id="找主题克隆到本地"><a href="#找主题克隆到本地" class="headerlink" title="找主题克隆到本地"></a>找主题克隆到本地</h2><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210823062446217.png" alt="image-20210823062446217"></p><p>进入Github以后将他Clone到本地，克隆到本地的themes文件夹下，然后重命名为上图左下角GitHub链接名Life，可能会受到网络的影响，一次克隆不下来，多克隆几次就好</p><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210823062703453.png" alt="image-20210823062703453"></p><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210823063451936.png" alt="image-20210823063451936"></p><h2 id="修改Hexo的配置"><a href="#修改Hexo的配置" class="headerlink" title="修改Hexo的配置"></a>修改Hexo的配置</h2><p>找到 _config.yml文件夹</p><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210823063752179.png" alt="image-20210823063752179"></p><h2 id="重新生成代码"><a href="#重新生成代码" class="headerlink" title="重新生成代码"></a>重新生成代码</h2><pre><code>hexo clean</code></pre><pre><code>hexo g</code></pre><pre><code>hexo s</code></pre><p> 重新跑起来以后出现如下这种情况，缺少hexo-renderer-swig这个依赖</p><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210823064814169.png" alt="image-20210823064814169"></p><p>使用以下命令解决</p><pre><code> npm i hexo-renderer-swig</code></pre><p>下载完成 以后重新 hexo clean 清除缓存 hexo g 重新生成 hexo s 重新启动，如此一来更换主题就完成了</p><p><img src="/2021/08/23/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/image-20210823065744360.png" alt="image-20210823065744360"></p><p>如果想要部署到GitHub 直接hexo d即可</p><h1 id="解决图片显示不了的问题"><a href="#解决图片显示不了的问题" class="headerlink" title="解决图片显示不了的问题"></a>解决图片显示不了的问题</h1><p>1.首先安装一下依赖</p><pre><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre><p>2.然后把_config.yml中的post_asset_folder设为true，这个配置的意思是每次new post一个博客，会增加一个和博客同名的文件夹。</p><p>3.最后重新发布就行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="https://niuxiaocong.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Hexo" scheme="https://niuxiaocong.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
